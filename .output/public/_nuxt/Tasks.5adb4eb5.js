import{aa as C,r as u,v as w,E as P,ab as b,F as h,h as x,ac as k,ad as O,u as B,m as E,I as M,a7 as H,a8 as R,ae as z}from"./entry.b5608eb4.js";function A(...i){var m;const c=typeof i[i.length-1]=="string"?i.pop():void 0;typeof i[0]!="string"&&i.unshift(c);let[a,l,e={}]=i;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof l!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=k(),_=()=>null,D=()=>t.isHydrating?t.payload.data[a]:t.static.data[a];e.server=e.server??!0,e.default=e.default??_,e.getCachedData=e.getCachedData??D,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0,e.deep=e.deep??C.deep;const d=()=>![null,void 0].includes(e.getCachedData(a));if(!t._asyncData[a]||!e.immediate){(m=t.payload._errors)[a]??(m[a]=null);const r=e.deep?u:w;t._asyncData[a]={data:r(e.getCachedData(a)??e.default()),pending:u(!d()),error:P(t.payload._errors,a),status:u("idle")}}const s={...t._asyncData[a]};s.refresh=s.execute=(r={})=>{if(t._asyncDataPromises[a]){if(r.dedupe===!1)return t._asyncDataPromises[a];t._asyncDataPromises[a].cancelled=!0}if((r._initial||t.isHydrating&&r._initial!==!1)&&d())return Promise.resolve(e.getCachedData(a));s.pending.value=!0,s.status.value="pending";const f=new Promise((n,o)=>{try{n(l(t))}catch(g){o(g)}}).then(n=>{if(f.cancelled)return t._asyncDataPromises[a];let o=n;e.transform&&(o=e.transform(n)),e.pick&&(o=S(o,e.pick)),t.payload.data[a]=o,s.data.value=o,s.error.value=null,s.status.value="success"}).catch(n=>{if(f.cancelled)return t._asyncDataPromises[a];s.error.value=O(n),s.data.value=B(e.default()),s.status.value="error"}).finally(()=>{f.cancelled||(s.pending.value=!1,delete t._asyncDataPromises[a])});return t._asyncDataPromises[a]=f,t._asyncDataPromises[a]};const y=()=>s.refresh({_initial:!0}),v=e.server!==!1&&t.payload.serverRendered;{const r=E();if(r&&!r._nuxtOnBeforeMountCbs){r._nuxtOnBeforeMountCbs=[];const n=r._nuxtOnBeforeMountCbs;r&&(b(()=>{n.forEach(o=>{o()}),n.splice(0,n.length)}),h(()=>n.splice(0,n.length)))}v&&t.isHydrating&&(s.error.value||d())?(s.pending.value=!1,s.status.value=s.error.value?"error":"success"):r&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?r._nuxtOnBeforeMountCbs.push(y):e.immediate&&y(),e.watch&&x(e.watch,()=>s.refresh());const f=t.hook("app:data:refresh",async n=>{(!n||n.includes(a))&&await s.refresh()});r&&h(f)}const p=Promise.resolve(t._asyncDataPromises[a]).then(()=>s);return Object.assign(p,s),p}function S(i,c){const a={};for(const l of c)a[l]=i[l];return a}const j=M({__name:"Tasks",async setup(i){let c,a;const l=H();return R(),u(),u(!1),u(!1),u(""),[c,a]=z(async()=>A("tasks",async()=>{const{data:e}=await l.from("tasks").select("id, title, completed").eq("id",1);return console.log(e),e})),c=await c,a(),(e,t)=>null}});export{j as default};
